data Maybe a = { Just a | Nothing }

fun testJust : Int := {
  let foo = Just 5 in # 0
  let asdf = case foo of
    Just x => let _ = println("Got Just!") in x
    Nothing => let _ = println("ERROR: Got Nothing") in 0
  in asdf
}

data List a = { Nil | Cons a (List a) }

fun head (xs : List a) : Maybe a := {
  case xs of
    Nil => Nothing
    Cons h t => Just h
}

# FIXME: passing a function ref w/ unboxed argument to a function
# requiring a function ref w/ boxed argument does not work.
# Passed function ref needs to be automatically "promoted" to a
# boxed version.

# fun filter (xs : List a, f : a -> Bool) : List a := {
#   case xs of
#     Nil => Nil
#     Cons h t => if @f(h) then Cons h @filter(t, f) else @filter(t, f)
# }

fun filter (xs : List Int, f : Int -> Bool) : List Int := {
  case xs of
    Nil => Nil
    Cons h t =>
      let newT = @filter(t, f) in
      if @f(h) then Cons h newT else newT
}

fun lte5 (x: Int) : Bool := {
  x <= 5
}

fun numberList (n : Int) : List Int := {
  if n <= 0 then Nil else Cons n @numberList(n - 1)
}

fun printList (xs : List a, msg : String) : Int := {
  case xs of
    Nil => 0
    Cons h t =>
      let _ = println(msg) in
      @printList(t, msg)
}

fun main : Int := {
  let nums = @numberList(10) in
  let x1 = @printList(nums, "numberList") in
  let x2 = @printList(@filter(nums, &lte5), "filter(numberList, <= 5)") in
  x2
}

data AddTable a = { Add (a -> a -> a) }

fun add (x : a, y : a, table : AddTable a) : a := {
  case table of
    Add f => @f(x, y)
}

fun add_Int (x : Int, y : Int) : Int := {
  x + y
}

# fun addTable_Int : AddTable Int := {
#   let f = &add_Int in
#   Add f
# }
